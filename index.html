<html>
	<head>
		<title>Project Tissi - Filippi</title>
		<style>
            body {
                font-family: Monospace;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
            canvas {
                width: 100%;
                height: 100%;
            }
        </style>
        <script src="lib/three.min.js"></script>
        <script src="lib/stats.min.js"></script>
        <script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<script src="lib/RectAreaLightUniformsLib.js"></script>
        <script src="scripts/main.js"></script>
		<script src="scripts/lights.js"></script>
		<script src="objs/steps.js"></script>
		<script src="objs/wall.js"></script>
		<script src="objs/column.js"></script>
		<script src="objs/roof.js"></script>
		<script src="objs/character_outside.js"></script>
		<script src="objs/character_inside.js"></script>
	</head>
	<body>
		
		<script>
		let scene, camera, renderer, controls, stats;
		let sfera, guard_sx, guard_dx;
		let direction = false;
		let direction_2 = false;
		let direction_3 = false;
		let direction_4 = false;
		const RIENTRO = 15;
		const H_STEP = 5; 
		const WIDTH_STEPS = 205;
		const DEPH_STEPS = 245;
		const H_WALL = 15;
		const WIDTH_WALL = 5;
		const TOWER_BASE = 5;
		const H_TOWER = (3/2) * H_WALL;
		const ROOF_SIZE = 115;
		const ROOF_DEPH = 175;
		const COLUMN_CAPITAL_SIZE = 15;
		const Z_COLUMN = 75;
		const X_COLUMN = 45;
		//resize window
		window.addEventListener('resize', function () {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
		});
		
		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( "rgb(30,144,255)" );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );
			
			camera.position.set(300,200,400);
			camera.lookAt( new THREE.Vector3(0,0,0));
			

			/*********************TEMPIO*******************/
			let tempio = new THREE.Object3D();
			scene.add(tempio);
			//Aggiungo i gradini
			let steps = new Steps(WIDTH_STEPS, DEPH_STEPS);
			let s = steps.getSteps();
			tempio.add(s);
			//Aggiungo il muretto
			let wall = new Wall(WIDTH_STEPS, DEPH_STEPS);
			let w = wall.getWall();
			w.position.y = H_STEP*3;
			tempio.add(w);

			//Aggiungo le 6 colonne a sinistra
			let columns_sx = [];
			let columns_sx_add = [];
			for(let i=0; i<6; i++){
				columns_sx.push(new Column());
				columns_sx_add.push(columns_sx[i].getColumn());
				tempio.add(columns_sx_add[i]);
				columns_sx_add[i].position.set(-X_COLUMN,0, -Z_COLUMN + i*30);
			}

			//Aggiungo le 6 colonne a destra
			let columns_dx = [];
			let columns_dx_add = [];
			for(let i=0; i<6; i++){
				columns_dx.push(new Column());
				columns_dx_add.push(columns_dx[i].getColumn());
				tempio.add(columns_dx_add[i]);
				columns_dx_add[i].position.set(X_COLUMN,0, -Z_COLUMN + i*30);
			}
			
			//Aggiungo le 2 colonne dietro
			let columns_back = [];
			let columns_back_add = [];
			for(let i=0; i<2; i++){
				columns_back.push(new Column());
				columns_back_add.push(columns_back[i].getColumn());
				tempio.add(columns_back_add[i]);
				columns_back_add[i].position.set(-15 + i*30, 0, -Z_COLUMN);
			}
			
			//Aggiungo le 2 colonne davanti
			let columns_front = [];
			let columns_front_add = [];
			for(let i=0; i<2; i++){
				columns_front.push(new Column());
				columns_front_add.push(columns_front[i].getColumn());
				tempio.add(columns_front_add[i]);
				columns_front_add[i].position.set(-15 + i*30, 0, Z_COLUMN);
			}
			
			//Aggiungo tetto
			let roof = new Roof(105, 165);
			let r = roof.getRoof();
			r.position.y = columns_front[0].getHColumn() + H_STEP*3;
			tempio.add(r);


			/******************************PERSONAGGI****************************/
			//Aggiungo Prete interno
			let png_priest = new CharacterInside();
			let priest = png_priest.getCharacter();
			scene.add(priest);
			priest.rotation.y = 180*Math.PI/180;
			priest.position.z = 30;

			//Aggiungo Guardia sx
			let png_guard_sx = new CharacterOutside();
			guard_sx = png_guard_sx.getCharacter();
			scene.add(guard_sx);
			guard_sx.rotation.y = 180*Math.PI/180;
			guard_sx.position.z = 85;
			guard_sx.position.x = -67.5;
			//guard_sx.position.y = 27;
			console.log(guard_sx.position.y);
			//Aggiungo Guardia dx
			let png_guard_dx = new CharacterOutside();
			guard_dx = png_guard_dx.getCharacter();
			scene.add(guard_dx);
			guard_dx.position.z = -85;
			guard_dx.position.x = 67.5;


			/*********************** "SFERA" CHE RUOTA ********************/
			//Posizioniamo un "altarino"
			let altar = new Steps(40, 40);
			let a = altar.getSteps();
			a.position.y = H_STEP*3; 
			a.position.z = -30; 
			tempio.add(a);

			let sferaG = new THREE.BoxGeometry(20,20,20);
			let sfera_tex = new THREE.TextureLoader().load('textures/sfera_tex.png');
			let sferaM_array = [
                new THREE.MeshPhongMaterial({map: sfera_tex, opacity: .8, transparent: true}), 
                new THREE.MeshPhongMaterial({map: sfera_tex, opacity: .8, transparent: true}),
                new THREE.MeshPhongMaterial({map: sfera_tex, opacity: .8, transparent: true}),
                new THREE.MeshPhongMaterial({map: sfera_tex, opacity: .8, transparent: true}),
                new THREE.MeshPhongMaterial({map: sfera_tex, opacity: .8, transparent: true}),
                new THREE.MeshPhongMaterial({map: sfera_tex, opacity: .8, transparent: true})
            ]; 
			
			let sferaM = new THREE.MultiMaterial(sferaM_array);
			sfera = new THREE.Mesh(sferaG, sferaM);
			scene.add(sfera);
			sfera.position.set(0,60,-30);

			/******************************LUCI****************************/
            setHemiLight();

            setDirectionalLight();

			/******************************TERRENO****************************/
            setGround();
			
			
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			
			// uncomment if you need to draw coordinate axes when building the scene
			// Coordinates.drawAllAxes();
			
			controls = new THREE.OrbitControls( camera, renderer.domElement );
			
		}
		
		function Update() {
			requestAnimationFrame( Update );
			controls.update();
			//Animazione sfera
			sfera.rotation.x+=0.01;
			sfera.rotation.y+=0.01;

			//Animazione guardia sx
			//Avanti e indietro
			if(guard_sx.position.z>=-85 && !direction){
				guard_sx.position.z-=0.4;
			}else if(guard_sx.position.z<=85 && direction){
				guard_sx.position.z+=0.4;
			}
			if(guard_sx.position.z<=-85 || guard_sx.position.z>=85 ){
				direction = !direction;
				guard_sx.rotation.y += 180 * Math.PI/180;
			}
			//Su e giÃ¹
			if(guard_sx.position.y>=23 && !direction_3)
				guard_sx.position.y-=0.3;
			else (guard_sx.position.y<=25 && direction_3)
				guard_sx.position.y+=0.3;
			if(guard_sx.position.y<=23 || guard_sx.position.y>=25 ){
				direction_3 = !direction_3;
			}
			
					
			//Animazione guardia dx
			if(guard_dx.position.z<=85 && !direction_2){
				guard_dx.position.z+=0.4;
			}else if(guard_dx.position.z>=-85 && direction_2){
				guard_dx.position.z-=0.4;
			}
			if(guard_dx.position.z<=-85 || guard_dx.position.z>=85 ){
				direction_2 = !direction_2;
				guard_dx.rotation.y += 180 * Math.PI/180;
			}
			
				

			//guard_sx.position.z-=0.1;

			stats.update();
			Render();
		}
		
		function Render() {
			
			renderer.render(scene, camera);
		}
		
		Start();
		Update();
			
		</script>
	</body>
</html>