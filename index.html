<html>
	<head>
		<title>Project Tissi - Filippi</title>
		<style>
            body {
                font-family: "Courier New", Courier, monospace;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
            canvas {
                width: 100%;
                height: 100%;
			}

			#info_light{
				position: absolute;
				left: 0;
				right: 0;
				margin: 0 auto;
				width: 50%;
				text-align: center;
				padding-top: 20px;
				font-size: 18px;
			}
        </style>
        <script src="lib/three.min.js"></script>
        <script src="lib/stats.min.js"></script>
        <script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<script src="lib/RectAreaLightUniformsLib.js"></script>
        <script src="scripts/main.js"></script>
		<script src="scripts/lights.js"></script>
		<script src="objs/steps.js"></script>
		<script src="objs/wall.js"></script>
		<script src="objs/column.js"></script>
		<script src="objs/roof.js"></script>
		<script src="objs/character_outside.js"></script>
		<script src="objs/character_inside.js"></script>
		<script src="objs/decoration.js"></script>
	</head>
	<body>
		<div id="info_light"></div>
		<script>
		let scene, camera, renderer, controls, stats;
		let sfera, guard_sx, guard_dx;
		let direction = false;
		let direction_2 = false;
		let direction_3 = false;
		let direction_4 = false;
		let direction_5 = false;
		let h_decoration = 8;
		let light_div;
		//Costanti per creazione del tempio: utilizzate anche in altre classi
		const RIENTRO = 15;
		const H_STEP = 5; 
		const WIDTH_STEPS = 205;
		const DEPH_STEPS = 245;
		const H_WALL = 15;
		const WIDTH_WALL = 5;
		const TOWER_BASE = 5;
		const H_TOWER = (3/2) * H_WALL;
		const ROOF_SIZE = 115;
		const ROOF_DEPH = 175;
		const COLUMN_CAPITAL_SIZE = 15;
		const Z_COLUMN = 75;
		const X_COLUMN = 45;
		//resize window event
		window.addEventListener('resize', function () {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
		});
		
		function Start() {
			light_div = document.getElementById("info_light");
			light_div.innerHTML = "Clicca " + "<b>'a'</b>" + " per cambiare il colore della luce";
			
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( "rgb(30,144,255)" );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );
			
			camera.position.set(300,200,400);
			camera.lookAt( new THREE.Vector3(0,0,0));
			

			/*********************TEMPIO*******************/
			let tempio = new THREE.Object3D();
			scene.add(tempio);
			//Aggiungo i gradini
			let steps = new Steps(WIDTH_STEPS, DEPH_STEPS);
			let s = steps.getSteps();
			tempio.add(s);

			//Aggiungo il muretto
			let wall = new Wall(WIDTH_STEPS, DEPH_STEPS);
			let w = wall.getWall();
			w.position.y = H_STEP*3;
			tempio.add(w);

			//Aggiungo le 6 colonne a sinistra
			let columns_sx = [];
			let columns_sx_add = [];
			for(let i=0; i<6; i++){
				columns_sx.push(new Column());
				columns_sx_add.push(columns_sx[i].getColumn());
				tempio.add(columns_sx_add[i]);
				columns_sx_add[i].position.set(-X_COLUMN,0, -Z_COLUMN + i*30);
			}

			//Aggiungo le 6 colonne a destra
			let columns_dx = [];
			let columns_dx_add = [];
			for(let i=0; i<6; i++){
				columns_dx.push(new Column());
				columns_dx_add.push(columns_dx[i].getColumn());
				tempio.add(columns_dx_add[i]);
				columns_dx_add[i].position.set(X_COLUMN,0, -Z_COLUMN + i*30);
			}
			
			//Aggiungo le 2 colonne dietro
			let columns_back = [];
			let columns_back_add = [];
			for(let i=0; i<2; i++){
				columns_back.push(new Column());
				columns_back_add.push(columns_back[i].getColumn());
				tempio.add(columns_back_add[i]);
				columns_back_add[i].position.set(-15 + i*30, 0, -Z_COLUMN);
			}
			
			//Aggiungo le 2 colonne davanti
			let columns_front = [];
			let columns_front_add = [];
			for(let i=0; i<2; i++){
				columns_front.push(new Column());
				columns_front_add.push(columns_front[i].getColumn());
				tempio.add(columns_front_add[i]);
				columns_front_add[i].position.set(-15 + i*30, 0, Z_COLUMN);
			}
			
			//Aggiungo le decorazioni davanti
			let decorationsF = [];
			let decorationsF_add = [];
			for(let i=0; i<3; i++){
				decorationsF.push(new Decorations(h_decoration,1));
				decorationsF_add.push(decorationsF[i].getDecorations());
				tempio.add(decorationsF_add[i]);
				decorationsF_add[i].position.set(-30 + i*30 , H_STEP*3+columns_front[0].getHColumn()+(h_decoration/2) + 1, Z_COLUMN + h_decoration);
			}

			//Aggiungo le decorazioni dietro
			let decorationsB = [];
			let decorationsB_add = [];
			for(let i=0; i<3; i++){
				decorationsB.push(new Decorations(h_decoration,1));
				decorationsB_add.push(decorationsB[i].getDecorations());
				tempio.add(decorationsB_add[i]);
				decorationsB_add[i].position.set(-30 + i*30 ,H_STEP*3+columns_front[0].getHColumn()+(h_decoration/2) + 1, -(Z_COLUMN + h_decoration));
			} 

			//Aggiungo le decorazioni lato sinistro
			let decorationsSx = [];
			let decorationsSx_add = [];
			for(let i=0; i<5; i++){
				decorationsSx.push(new Decorations(h_decoration,1));
				decorationsSx_add.push(decorationsSx[i].getDecorations());
				tempio.add(decorationsSx_add[i]);
				decorationsSx_add[i].rotation.y = 90*Math.PI/180;
				decorationsSx_add[i].position.set(-52.5 , H_STEP*3+columns_front[0].getHColumn()+(h_decoration/2) + 1, -60 + i*30);
			} 

			//Aggiungo le decorazioni lato destro
			let decorationsDx = [];
			let decorationsDx_add = [];
			for(let i=0; i<5; i++){
				decorationsDx.push(new Decorations(h_decoration,1));
				decorationsDx_add.push(decorationsDx[i].getDecorations());
				tempio.add(decorationsDx_add[i]);
				decorationsDx_add[i].rotation.y = 90*Math.PI/180;
				decorationsDx_add[i].position.set(52.5 , H_STEP*3+columns_front[0].getHColumn()+(h_decoration/2) + 1 , -60 + i*30);
			}

			//Aggiungo tetto
			let roof = new Roof(105, 165);
			let r = roof.getRoof();
			r.position.y = columns_front[0].getHColumn() + H_STEP*3;
			tempio.add(r);


			/******************************PERSONAGGI****************************/
			//Aggiungo Prete interno
			let png_priest = new CharacterInside();
			let priest = png_priest.getCharacter();
			scene.add(priest);
			priest.rotation.y = 180*Math.PI/180;
			priest.position.z = 30;

			//Aggiungo Guardia sx
			let png_guard_sx = new CharacterOutside();
			guard_sx = png_guard_sx.getCharacter();
			scene.add(guard_sx);
			guard_sx.rotation.y = 180*Math.PI/180;
			guard_sx.position.z = 85;
			guard_sx.position.x = -67.5;
			guard_sx.position.y = 26;
			//Aggiungo Guardia dx
			let png_guard_dx = new CharacterOutside();
			guard_dx = png_guard_dx.getCharacter();
			scene.add(guard_dx);
			guard_dx.position.z = -85;
			guard_dx.position.x = 67.5;


			/*********************** "SFERA" CHE RUOTA ********************/
			//Posizioniamo un "altarino"
			let altar = new Steps(40, 40);
			let a = altar.getSteps();
			a.position.y = H_STEP*3; 
			a.position.z = -30; 
			tempio.add(a);
			//Creiamo e posizioniamo la "sfera"
			let sferaG = new THREE.BoxGeometry(20,20,20);
			let sfera_tex = new THREE.TextureLoader().load('textures/sfera_tex.png');
			let sferaM_array = [
                new THREE.MeshPhongMaterial({map: sfera_tex, opacity: .8, transparent: true}), 
                new THREE.MeshPhongMaterial({map: sfera_tex, opacity: .8, transparent: true}),
                new THREE.MeshPhongMaterial({map: sfera_tex, opacity: .8, transparent: true}),
                new THREE.MeshPhongMaterial({map: sfera_tex, opacity: .8, transparent: true}),
                new THREE.MeshPhongMaterial({map: sfera_tex, opacity: .8, transparent: true}),
                new THREE.MeshPhongMaterial({map: sfera_tex, opacity: .8, transparent: true})
            ]; 
			
			let sferaM = new THREE.MultiMaterial(sferaM_array);
			sfera = new THREE.Mesh(sferaG, sferaM);
			scene.add(sfera);
			sfera.position.set(0,65,-30);
			let light_color = setRandomColor();
			let light = new THREE.PointLight( light_color, 1, 100 );
			light.position.set(0,0,0);
			sfera.add(light);
			let onKeyPress = function(event) {
				if (event.key == 'a') {
					light.color.setRGB(Math.random(), Math.random(), Math.random());
				}
			};
			document.addEventListener("keydown", onKeyPress);

			/******************************LUCI****************************/
            setHemiLight();

            setDirectionalLight();

			/******************************TERRENO****************************/
            setGround();
			
			
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			
			// uncomment if you need to draw coordinate axes when building the scene
			// Coordinates.drawAllAxes();
			
			controls = new THREE.OrbitControls( camera, renderer.domElement );
		}
		
		function Update() {
			requestAnimationFrame( Update );
			controls.update();
			/************** ANIMAZIONE SFERA *************/
			sfera.rotation.x+=0.01;
			sfera.rotation.y+=0.01;
			//Su e giù
			if(sfera.position.y>=55 && !direction_5)
				sfera.position.y-=0.09;
			else if(sfera.position.y<=65 && direction_5)
				sfera.position.y+=0.09;
			if(sfera.position.y<=55 || sfera.position.y>=65 ){
				direction_5 = !direction_5;
			}

			/************** ANIMAZIONE GUARDIA SX *************/
			//Avanti e indietro
			if(guard_sx.position.z>=-85 && !direction){
				guard_sx.position.z-=0.3;
			}else if(guard_sx.position.z<=85 && direction){
				guard_sx.position.z+=0.3;
			}
			if(guard_sx.position.z<=-85 || guard_sx.position.z>=85 ){
				direction = !direction;
				guard_sx.rotation.y += 180 * Math.PI/180;
			}

			//Su e giù
			if(guard_sx.position.y>=22 && !direction_3)
				guard_sx.position.y-=0.09;
			else if(guard_sx.position.y<=26 && direction_3)
				guard_sx.position.y+=0.09;
			if(guard_sx.position.y<=22 || guard_sx.position.y>=26 ){
				direction_3 = !direction_3;
			}
			
					
			/************** ANIMAZIONE GUARDIA DX *************/
			//Avanti e indietro
			if(guard_dx.position.z<=85 && !direction_2){
				guard_dx.position.z+=0.3;
			}else if(guard_dx.position.z>=-85 && direction_2){
				guard_dx.position.z-=0.3;
			}
			if(guard_dx.position.z<=-85 || guard_dx.position.z>=85 ){
				direction_2 = !direction_2;
				guard_dx.rotation.y += 180 * Math.PI/180;
			}
			//Su e giù
			if(guard_dx.position.y>=22 && !direction_4)
				guard_dx.position.y-=0.09;
			else if(guard_dx.position.y<=26 && direction_4)
				guard_dx.position.y+=0.09;
			if(guard_dx.position.y<=22 || guard_dx.position.y>=26 ){
				direction_4 = !direction_4;
			}
			
				

			//guard_sx.position.z-=0.1;

			stats.update();
			Render();
		}
		
		function Render() {
			
			renderer.render(scene, camera);
		}
		
		Start();
		Update();
			
		</script>
	</body>
</html>